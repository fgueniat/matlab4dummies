\input{preamble.tex}













%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Quick tour \matlab}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Legal stuff}
\matlab is a registered trademark of MathWorks, Inc.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{What is the use of \matlab ?}
\matlab~(for MATrix LABoratory) aims at delivering quickly some \emph{relatively} inexpensive computations.
It shines, as expected from the name, when it involves linear algebra, i.e., operations on matrices.

The main advantage of \matlab compared to language like C/C++ or Fortran are:
\begin{itemize}
	\item No compilation
	\item The prompt
	\item Simplicity
	\item portability
	\item Built-in functions:
		\begin{itemize}
			\item integration
			\item visualization
			\item tool-box
		\end{itemize}
\end{itemize}

The negative points are mostly:
\begin{itemize}
	\item sub performance
	\item not open source
	\item {\color{red} price}
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Equivalent of \matlab }

Octave and SciLab are almost identical to \matlab. A \matlab script would work on these two others open-source and free softwares.

Most of the tips can also be applied to python, especially when the packages scipy and numpy (for scientific and engineering computations) are used.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Philosophical idea of these teachings}
The objective of these tutorial are to illustrate the ENG 4XXX courses as well at to help you to learn quickly how to numerically solve problems.
It will hence give you the first concepts behind \matlab, coding and problem solving.
The emphasis here is “learning by doing”. Therefore, try not to read these documents without a computer close-by.






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Hello World}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\matlab as a software}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Start \matlab}
Click on the icon, duh!
%%!!!!!!!!!!!!111
\subsubsection{Organization of the window}

You can find a few important sections:
\begin{itemize}
	\item the command windows \\
		\comments{This is the command prompt}
	\item current folder \\
		\comments{It lists the files}
	\item the Workspace \\
		\comments{It gives details on the objects present in memory}
	\item the editor \\
		\comments{this is where you can write a script}
	\item the ribbon \\
		\comments{It gives access to properties, functions, etc. Similar in spirit to Words and Excel.}
\end{itemize}

\todoimage{opening windows of matlab}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{How to print "hello world"}

Click on the Command Window, and type "hello world".
You will see:

\begin{lstlisting}
>> 'Hello World'
ans =
Hello World
\end{lstlisting}

\medskip

\matlab~printed the 'Hello World', congratulations !

You can see also that the 'Hello World has been assignated to a variable named ans.

\defbox{ans}{\mcode{ans} is short for answer. 

	The results of the command is always stored in the variable ans, except if it is assigned to a given variable. Consequently, the command \mcode{ 1+1}  will affect the variable \mcode{ans}, but \mcode{x=1+1} will not, and \mcode{2} will be assign to \mcode{x}. 

	\mcode{ans} can be re-used in the prompt: \mcode{x = ans+1}. 
However, a good practice is to assign the result to a user-defined variable.
}


Now, try without the quotes, and you will see:
\begin{lstlisting}
>> Hello World
<@{\color{red}Undefined function or variable 'Hello'.}@>
\end{lstlisting}
plus some help.

Hello World is understood by \matlab as a function/variable and then an option for this function.
\matlab hence thinks that Hello is something that already exists, and it is not the case here. An error follow.

The main reason behind that is that we want to print a string.

\defbox{String}{A string is a chain of characters. It is \emph{not} a number. 

It has to be between quotes: 'some text' or double quotes: "some text". 
For example, 'Lorem ipsum dolor sit amet' is a chain or characters.

But it is not that easy. \mcode{s = '45'} is the chain of characters '4' and '5'. But \mcode{n = 45} is the number 45. \mcode{s} and \mcode{n} are different.  

}


Try now to add a semi colon at the end of the line:
\begin{lstlisting}
>> 'Hello World';
>>
\end{lstlisting}

Nothing is printed in the command prompt.

\defbox{Command prompt}{The command prompt is the $>>$ sign. 
	
Command Prompt is a command line interpreter. It is used to execute entered commands. 
Once enter is hit, \matlab will interpret the command, and send back any results.
}

One of the most important tip to remember: \matlab will always print the result of a line if it does not have a ";" at the end of the line.

\tipbox{
Do not forget  the ";" at the end of lines !

It is not a big deal when dealing with small matrices and small vectors.
But when an image is being manipulated, it means that \matlab is manipulated a matrix with dimension around $1000\times1000$.
Forgetting the ";" sign means that \matlab will show around a \emph{million} numbers every line of your script!
}






\section{\matlab as a calculator}
\subsection{Algebra}

You can use \matlab as a calculator. 
Click on the prompt: 

\begin{lstlisting}
>> 4+3
ans =
7
>> 4*3
ans =
12
\end{lstlisting}

As expected, \matlab respects the BODMAS (Brackets, Order, Division/Multiplication, Addition/Subtraction). 
Try a few operations !
\begin{lstlisting}
>> (4+3)*2
ans =
14
>> 4+3*2
ans =
10
\end{lstlisting}

\subsection{Variables}
ans can be used to store a result, but it will be overwritten every time a command is executed:

\begin{lstlisting}
>> 2+2
ans =
4
>> ans+2
ans =
6
>> ans+2
ans =
8
\end{lstlisting}

\subsection{Creation and re-assignement}

Variable can be easily created and assigned with the sign "=". 


\begin{lstlisting}
>> x = 2+2
x =
4
>> x+2
ans =
6
>> x*5
ans =
10
\end{lstlisting}

\defbox{Variable}{A variable is essentially a name that is associated with a value. 

Values can be of several types:
\begin{itemize}
\item results, such as string, numbers or matrices: \mcode{x = 3.}
\item functions, for instance \mcode{sin} is a built-in function
\item complex objects, for instance, a plot
\end{itemize}
They are usually assigned with the sign "="
}

%%!!!!!!!!!!!!111
\subsubsection{Naming convention}
A variable name can be anything, such as \mcode{goodnameforavariable} or  \mcode{GoodNameForAVariable}, or  \mcode{good\_name\_for\_a\_variable} .
However:
\begin{itemize}
	\item it cannot start with \_
	\item it cannot start with a number
	\item a few names are protected
\end{itemize}

\tipbox{Try to use clever name for variables, it will help to understand the code.

	If all the results are named \mcode{result\_1,result\_2,result\_3}, it is hard to know what they should contain.

	On the contrary, if you have the variable \mcode{name\_city}, you expect it to be a string and having a proper name.

	In a similar way, if you have the variable \mcode{motor\_freq}, you expect it to be a number.


	Also, if you have the variable \mcode{price\_pond}, the variable \mcode{price\_dollar} and the variable \mcode{rate\_dollar2pound}, the line \mcode{price\_pound = rate\_dollar2pond * price\_dollar} is pretty explicit.
	If the variables where instead named \mcode{x,y,z}, then the line \mcode{x = y*z} is much more cryptic.
}


The choice of a name is important, for you a, \mcode{x} is good for an unknown, \mcode{s} if you expect its value to be a string, \mcode{v} if it is a vector... More complex names can be used, such as \mcode{x\_problem\_1}. Try to be consistent thorough the piece of code !

A few tips:

\begin{itemize}
	\item Use different names for different results
	\item Use a name that is meaningfull (e.g. \mcode{str\_name} if the variable is assigned with a chain of character that is a name)
	\item Consequently, avoid unecessary use of index (e.g. \mcode{result\_1, result\_2} etc.)
\end{itemize}

\tipbox{
	Many naming convention exist.
	
	However, you can use the following name convention: \\
	\begin{itemize}
		\item \mcode{UpperCamelCase} for functions: \mcode{MyFunction}
		\item \mbox{\mcode{CAPITALIZED\_WITH\_UNDERSCORES}} for constants \mcode{Pi=3.14}
		\item \mbox{\mcode{lowercase\_separated\_by\_underscores}} for other variables \mcode{name\_of\_univ = 'BCU'}.
	\end{itemize}
		}


%%!!!!!!!!!!!!111
\subsubsection{Reassignement}
Updating a variable is handy: you might want to change the variable \mcode{year} from \mcode{2017} to \mcode{2018}.

You can easily update a variable, by reassigning a new value to it. It hence uses the sign "=".
For instance:
\begin{lstlisting}
>> x = 2+2
x = 
4
>> x = x + 5
x =
9
>> x = 0
x =
0
\end{lstlisting}


%%!!!!!!!!!!!!111
\subsubsection{Exercices}
\begin{enumerate}
	\item Create the variables \mcode{x,y,z} assigned with $1$, $2$ and $3$.
	\item Create the variable \mcode{sum\_xyz} that is the sum of \mcode{x,y} and \mcode{z}.
	\item Propose a name for a variable that is assigned as a value \mcode{'Birmingham'}
	\item Propose a name for a variable that is assigned as a value \mcode{'BCU'}
	\item Try to assign to the variable \mcode{year} the value \mcode{2017}, and then to \mcode{2018}!
	\item Try to assign to the variable \mcode{girlfriend\_name} the value \mcode{'Adilah'} (using the sign equal, pun totally intended), and to the variable \mcode{ex\_girlfriend\_name} the value \mcode{'Marie'}.
Then, reassign to the variable \mcode{girlfriend\_name} the value \mcode{'Kiara'}, and to the variable \mcode{ex\_girlfriend\_name} the value \mcode{'Adilah'}.

\end{enumerate}


\subsection{Workspace}
When you have created a variable, it is available in the \emph{workspace}.
It is the area (usually) on the right.
It allows to:
\begin{itemize}
	\item show what variables are currently known to \matlab
	\item know what is present in the memory
	\item indicate what there is in the variables
	\item eventually modify the content of a variable
\end{itemize}

\subsection{Entering multiple commands per line}
It is possible to enter multiple commands per line. 
Use commas "," or semicolons ";" for that ; the commas will \emph{not} suppress the outputs.

\tipbox{Try to avoid multiple commands per line.
	
Most of the time, it makes the code harder to read, especially if there is not a good reason to do so.

Nevertheless, it can make sense write a few commands per line when assigning a variables that are related.
}

\begin{lstlisting}
>> x = 2 ; y = 3 ; z = 4 ;
>> x = 2 ; y = 3 , z = 4 ;
y = 
3
>> x = 2 , y = 3 , z = 4 ,
x = 
2
y = 
3
z = 
5
\end{lstlisting}



\subsection{Basic arithmetic}


Basic arithmetic operators are pretty classic:

\begin{table}[h!]\caption{Arithmetic operators}
\center
\begin{tabular}{|l|c|c|}
	\hline
	operation & command & exemple \\
	\hline
	addition & + & 3+4 \\
	soustraction & - & 3-4 \\
 	multiplication & * & 3*4 \\
	division & / & 3/4 \\
	power & \^{} & 2 \^{} 4 \\
	\hline
\end{tabular}
\end{table}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{functions}
%%!!!!!!!!!!!!111
\subsubsection{How to find a function or a command ?}

If you look for something, hit the help button.
For instance, if you want to look for the sine function:

\todoimage{help sine}


\tipbox{Use the help! It is \emph{very} useful and you will mostly find any function/tool/infos that you need.

Usually, the help contains a few examples. Do not hesitate to read them carefully, and to try them.
They will help understanding how to use the functions and properties of \matlab.

There is also a "See Also" section that can be useful when looking for a particular topic.
}

%%!!!!!!!!!!!!111
\subsubsection{Using a function}
Calling a function is relatively easy and intuitive. Let's take the sine function as an illustration. 

\begin{lstlisting}
>> sin(3.14)
ans =
0.0016
\end{lstlisting}

You ask \matlab to evaluate the function \mcode{sin} in $3.14\approx \pi$. 
For that, you just put the argument in parenthesis.

\tipbox{
	Trigonometric functions in \matlab are in radiant. \mcode{sin(360)} is hence different from $0$ but rather close to $0.96$.
	
	In a similar spirit, \mcode{log} in \matlab is the natural logarithm, and not the $\log$ in base 10.
}

Typical functions are available with somewhat explicit names, see Tab.~\ref{tab-funcs_matlab}. Similarly, many useful constants for the engineer are implemented in \matlab, see Tab.~\ref{tab-consts_matlab}.

\begin{table}[h!]
	\caption{A few function names in \matlab. Many others are already implemented in \matlab.}
	\label{tab-funcs_matlab}
\center
\begin{tabular}{|l|c||l|c||l|c|}
	\hline
	Trigonometry & name & Stats & name & Misc. & name\\
	\hline
	sine & sin  &
		mean & mean &
			square root & sqrt \\
			
	cosine & cos &
		maximum & max &
			absolute value & abs \\

	exponential & exp &
		minimum & min &
			round up & ceil \\		

		
	natural logarithm & log &
		standard dev. & std &
			conjugate & conj \\
	
	\hline
\end{tabular}
\end{table}

\begin{table}[h!]
	\caption{A few useful constant names in \matlab.}
	\label{tab-consts_matlab}
\center
\begin{tabular}{|l|c|}
	\hline
	$\pi\approx 3.14$ & \mcode{pi} \\
	$i = \sqrt{-1} $ & \mcode{i} \\
	$i = \sqrt{-1} $ & \mcode{j} \\
	$\infty$ & \mcode{Inf }\\
	Not a Number & \mcode{NaN} \\
	\hline
\end{tabular}
\end{table}





\section{Let's solve a real problem}

\paragraph*{Problem}
Julie's car's odometer reading was 35201km when she last filled the fuel tank. 
Yesterday she checked it again and it read 35403km. Checking the tank, the car used 11 liters of gas to do so.
If her car's gas tank holds 35 liters, how long can she drive before running out of gas? 


\paragraph*{Solution using \matlab as a calculator}

How much has she driven ?
\begin{lstlisting}
>> 35403 - 35201
ans =
202
\end{lstlisting}

How much distance per liter of gas ?
\begin{lstlisting}
>> 202/11
ans =
18.3636
\end{lstlisting}

How much gas is left in the tank ?
\begin{lstlisting}
>> 35 - 11
ans =
24
\end{lstlisting}

Distance she can drive:
\begin{lstlisting}
>> 24 * 18.3636
ans =
440.7264
\end{lstlisting}


\paragraph*{Solution with variables}

We can script the same code. It means that we would just have to replace the value in the first three lines to update the whole code. 


\begin{lstlisting}
>> odormeter_before = 35201 ;
>> odormeter_after = 35403 ; 
>> used_gas = 11 ;
>> distance = odormeter_after - odormeter_before ;  
>> distance_per_liter = distance/used_gas ;
>> tank_capacity = 35;
>> estimated_distance = (tank_capacity - used_gas) * distance_per_liter
440.7264
\end{lstlisting}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{What to remember}

\matlab is basically a powerful calculator.

\subsection{Key example}
Let's summarize in a few examples everything we have seen.

\begin{lstlisting}
>> year = 2018;
>> next_year = year + 1
next_year = 
2019
>> angle = pi ;
>> ( 2.*cos(angle) + 1.) ^2 
ans = 
9.0
\end{lstlisting}











%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Basic Linear Algebra}

Linear algebra is the fundations of \matlab, and what makes it popular.

In particular, \matlab makes the manipulation of matrices and vectors very easy.

This section will show how to do:
\begin{itemize}
	\item operations involving vectors
	\item operations involving matrices
	\item operations involving both arrays and matrices
\end{itemize}






\section{Basics with matrices and vectors}
\subsection{Creation}
Follow the procedure:
\begin{itemize}
	\item start with a bracket [
	\item write each element of a column, separated with space or commas
	\item separate rows with a semi-colon
	\item end with the bracket ]
\end{itemize}


For creating a vector:

\begin{lstlisting}
>> v = [1,2,3]
v =
1 2 3
>> w = [0;1]
w =
0
1
\end{lstlisting}
\mcode{v} is a row vector and \mcode{w} is a column vector.

For creating a matrix, the following lines are equivalent:
\begin{lstlisting}
>> M =[1,0 ; 0,1];
M = 
1 0
0 1
>> m =[1,0 ; 0 1];
M = 
1 0
0 1
>> m =[ [1,0] ; [0 1]];
M = 
1 0
0 1
\end{lstlisting}

The last line shows that a matrix is virtually stacked vectors.

\subsection{Manipulation}
You can
\begin{itemize}
	\item add, subtract, multiply matrices if their sizes are compatible
	\item access to the ith element of matrix \mcode{M} using \mcode{M(i)}
	\item access to the (ith,jth) element of matrix \mcode{M} using \mcode{M(i,j)}
\end{itemize}	



To add a constant to a vector, a vector to another vector (it works identically for matrices) :
\begin{lstlisting}
>> v = [1 3];
>> v + 4
ans =
5 7
>> v*2.
ans =
2 6
>> w = [2,8];
>> v+w
ans =
3 11
>> w/2.
ans =
1 4
\end{lstlisting}

To access to an element of a vector  (it works identically for matrices) :

\begin{lstlisting}
>> v = [1 3 4 -2.5 8] ;
>> v(1)
ans = 
1
>> v(3)
ans = 
4
>> M = [[5,2];[9,-1]] ;
>> M(1,1)
ans =
5
>> M(2,1)
ans =
9
\end{lstlisting}

To delete or \emph{remove} the ith element, use the operator "[]":

\begin{lstlisting}
>> v = [1 3 4 -2.5 8] ;
>> v(1) = []
v = 
3 4 -2.5 8
\end{lstlisting}
It hence reduces the dimension of the vector. It works similarly for a matrix:
\begin{lstlisting}
>> A = [ [1 3 4] ; [-2.5 8 9]] ;
>> A(:,1) = []
A = 
3 4
8 9
\end{lstlisting}
The first column has been deleted.




\section{More details on vectors}
\subsection{Creation of a vector}
\subsubsection{Row vector}
Creating a vector \mcode{v} is easy. You just put all the components between brackets.
\begin{lstlisting}
>> v = [1,2,3]
v =
1 2 3
\end{lstlisting}
It is also possible to replace the commas with space:
\begin{lstlisting}
>> v = [1 2 3]
v =
1 2 3
\end{lstlisting}

It works fine but makes the code harder to read.

Let's create Cartesian vectors in dimension two. $e_x = (1,0)$ and $e_y = (0,1)$:


\begin{lstlisting}
>> ex = [1 0]
ex =
1 0
>> ey = [0,1]
ey =
0 1
\end{lstlisting}
 


\subsubsection{Column vector}
Creating a column vector is similar to creating a row vector, except that the element are separated with a semi-colon ";".


\begin{lstlisting}
>> v = [1;0;4]
v =
1
0
4
>> w = [0;1]
w =
0
1
\end{lstlisting}

\subsubsection{Transpose operator}
It is possible to change a column vector to a row vector, and reciprocally, by using the transpose operator "'".
\begin{lstlisting}
>> ex = [1;0]
ex =
1
0
>> ex'
ans =
1 0
>> ey = [0,1]
ey =
0 1
>> ey'
ans =
0
1
\end{lstlisting}


\subsection{Access to the elements of a vector}

\subsubsection{Access to one element}

The first element of a vector \mcode{v} is \mcode{v(1)}.
The second element is \mcode{v(2)}, and so forth.

Accessing the element of a vector is just calling the vector with specifying the desired element:

\begin{lstlisting}
>> x = [1 3 4 -2.5 8]
x = 
1 3 4 -2.5 8
>> x(1)
ans = 
1
>> x(3)
ans = 
4
>> x(4)
ans = 
-2.5
\end{lstlisting}




The last element of a vector can be called using the argument \mcode{end}:
You can also call the ith item from the end using \mcode{end-i}. 
\begin{lstlisting}
>> x = [1 3 4 -2.5 8]
x = 
1.000 3.000 4.000 -2.5 8.000
>> x(end)
ans = 
8
>> x(end-1)
ans = 
-2.5
>> x(end-2)
ans = 
4
\end{lstlisting}



\subsubsection{Access to several elements}

The operator ":" gives access to all the elements between the first and the last element (included), in a column vector:

\begin{lstlisting}
>> v = [1 3 4 -2.5 8];
>> v(:)
ans = 
1
3
4
-2.5
8
\end{lstlisting}

Accessing to all the elements between the second and fifth element of \mcode{v} is \mcode{v(2:5)}:

\begin{lstlisting}
>> v = [1 3 4 -2.5 8 12];
>> v(2:5)
ans = 
3
4
-2.5
8
\end{lstlisting}
To access to \emph{all} the elements between the first and the last element (included), in a column vector, simply use the colon operator:

\begin{lstlisting}
>> x = [1 3 4 -2.5 8];
>> x(:)
ans = 
1
3
4
-2.5
8
\end{lstlisting}



\tipbox{The colon operator is pivotal in \matlab. 
	
	It is noticeably useful to 
	\begin{itemize}
		\item generate lists: \mcode{x= 1:20}
		\item controlling loops (more in a following chapter): \mcode{for i=1:20}
		\item transform a matrix in a column vector \mcode{M(:)}
		\item extract sub-parts of vectors/matrices \mcode{M(2:4,1:2:8)}
	\end{itemize}

	More details in Sec.~\ref{sssec-colon}.

}

\subsubsection{Deleting elements}




In \matlab, using "[]" empty a variable. It is named the \emph{empty vector operator}.
	
When used on a part of a vector or a matrix, it simply \emph{deletes} this part.
It is \emph{gone}.
As a consequence, it reduces the dimensions of the matrix.


\begin{lstlisting}
>> v = [1 3 4 -2.5 8] ;
>> v(1) = []
v = 
3 4 -2.5 8
\end{lstlisting}




\subsection{Basic operations on vectors}
\subsubsection{Addition/subtraction}
It is easy to add or subtract a given value to \emph{all} the components of a vector, using the signs "+" and "-".

\begin{lstlisting}
>> x = [1 3]
x = 
1 3
>> x + 4
ans =
5 7
>> y = x - 2
y =
-1 1
>> z = [5 10 -1 8] + 3
z = 
8 13 2 11
\end{lstlisting}


Vectors can be added, as long as their dimensions correspond:

\begin{lstlisting}
>> ex = [1 0]; ey = [0,1] ;
>> ex + ey
ans =
1 1
>> ex - ey
ans =
1 -1
\end{lstlisting}

Of course, if their dimensions do not correspond, \matlab will send back and error:

\begin{lstlisting}
>> x =[1,0] ; y = [1,0,0];
>> x+y
<@{\color{red}Matrix dimensions must agree.}@>
\end{lstlisting}




\tipbox{\matlab considers vectors as 1D matrices. 

It is important when dealing with multiplication.

If \mcode{v=[1,2,3]}: 
\begin{itemize}
	\item \mcode{v*v'} is $14$ \\
		it is multiplying a $1\times 3$ matrix with a $3\times 1$ matrix.
	\item \mcode{v'*v} is \mcode{[[1,2,3];[2,4,6];[3,6,9]]} \\
		it is multiplying a $3\times 1$ matrix with a $1\times 3$ matrix.
	\item \mcode{v*v} will not work \\
		it is multiplying a $1\times 1$ matrix with a $1\times 3$ matrix; dimensions are not compatible.
\end{itemize}

}



\subsubsection{Multiplication}
\paragraph{Multiplication by a scalar}

It is easy to multiply or divide by a given value to \emph{all} the components of a vector, using the signs "*" and "/"

\begin{lstlisting}
>> x = [1 3]
x = 
1 3
>> x * 4
ans =
4 12
>> y = x / 2.
y =
0.5 1.5
>> z = 3 * [5 10 -1 8]
z = 
15 30 -3 24
\end{lstlisting}



\paragraph{dot product}
It can be done using the function \mcode{dot}.
\begin{lstlisting}
>> x =[1,0] ; y = [1,0];
>> dot(x,y)
ans = 
1
>> x(1) * y(1) + x(2) * y(2)
ans =
1
>> a =[0,0.5,2] ; b = [2,0,4];
>> dot(a,b)
ans = 
8
>> a(1) * b(1) + a(2) * b(2) + a(3) * b(3)    
and =
8
\end{lstlisting}



\paragraph{Element-wise multiplication}
Element-wise multiplication means that each element of a vector is multiply by the corresponding element of the other vector.
It is similar to the dot product \emph{except} for the sum.
The operator for that is ".*" (it is read "dot product", which is pretty stupid when you think about it!).

\begin{lstlisting}
>> x =[1,0] ; y = [1,0];
>> x.*y
ans = 
1 0
>> [x(1) * y(1), x(2) * y(2)]
ans =
1 0
>> a =[0,0.5,2] ; b = [2,0,4];
>> a.*b
ans = 
0 0 8
>> [a(1) * b(1), a(2) * b(2), a(3) * b(3)]
and =
0 0 8
\end{lstlisting}


\tipbox{In \matlab, using "." in front of an operator means that this operator will be applied element-wise (to each element of the vector/matrix).

	For instance, \mcode{v.\^{}2} means that \emph{all} the elements of \mcode{v} will be squared. If \mcode{v} is $[2,4,3]$, then   \mcode{v.\^{}2}  is $[2^2,4^2,3^2]$, or \mcode{[4,16,9]}.

}


\todo{exercices}

\section{Matrices}
\matlab sees vectors a line matrices. Building a matrix is the equivalent of stacking lines.
For that, \matlab uses the semi colon sign ";".
The following lines are equivalent:
\begin{lstlisting}
>> M =[1,0 ; 0,1];
M = 
1 0
0 1
>> m =[1,0 ; 0 1];
M = 
1 0
0 1
>> m =[ [1,0] ; [0 1]];
M = 
1 0
0 1
\end{lstlisting}

The last line shows that a matrix is virtually stacked vectors.


\subsection{Addition/subtraction}
It is easy to add or subtract a given value to \emph{all} the components of a matrix, using the signs "+" and "-".

\begin{lstlisting}
>> M = [[1 3];[2,4];
>> M + 4
ans =
5 7
6 8
>> A = M - 2
A =
3 5
4 6
\end{lstlisting}


Matrices can be added, as long as their dimensions correspond:

\begin{lstlisting}
>> M = [[1 0];[2,3]; A = [[2,-1];[1,1]];
>> M + A
ans =
3 -1
3  4
>> M - A
ans =
1 1
1 2
\end{lstlisting}

Of course, if their dimensions do not correspond, \matlab will send back and error:

\begin{lstlisting}
>> M =[[1,0];[1,0];[1,0] ; A = [[2,-1];[1,1]];
>> x+y
<@{\color{red}Matrix dimensions must agree.}@>
\end{lstlisting}



\subsubsection{Multiplication}
It is easy to multiply or divide by a given value to \emph{all} the components of a vector, using the signs "*" and "/"

\begin{lstlisting}
>> x = [1 3]
x = 
1 3
>> x * 4
ans =
4 12
>> y = x / 2.
y =
0.5 1.5
>> z = 3 * [5 10 -1 8]
z = 
15 30 -3 24
\end{lstlisting}

What is multiplication for vectors ?

Two definitions can be proposed.

\paragraph{dot product}
The first definition is the dot product between two vectors.
\defbox{dot product}{The dot product (or inner product) of two vectors is the sum of the multiplication of their components. If $u=(u_i),v=(v_i)$ are $n$-dimensional vectors, $<u,v>= \sum\limits_{i=1}^n u_i \times v_i $.}


It can be done using the function \mcode{dot}.
\begin{lstlisting}
>> x =[1,0] ; y = [1,0];
>> dot(x,y)
ans = 
1
>> x(1) * y(1) + x(2) * y(2)
ans =
1
>> a =[0,0.5,2] ; b = [2,0,4];
>> dot(a,b)
ans = 
8
>> a(1) * b(1) + a(2) * b(2) + a(3) * b(3)    
and =
8
\end{lstlisting}


\paragraph{Element-wise multiplication}
Another definition could be the element wise multiplication.
It means that each element of a vector is multiply by the corresponding element of the other vector.
It is similar to the dot product \emph{except} for the sum.
The operator for that is ".*" (it is read "dot product", which is pretty stupid when you think about it!).

\begin{lstlisting}
>> x =[1,0] ; y = [1,0];
>> x.*y
ans = 
1 0
>> [x(1) * y(1), x(2) * y(2)]
ans =
1 0
>> a =[0,0.5,2] ; b = [2,0,4];
>> a.*b
ans = 
0 0 8
>> [a(1) * b(1), a(2) * b(2), a(3) * b(3)]
and =
0 0 8
\end{lstlisting}



\todo{exercises}
Try to create the vector $x = (1,2,3,4)$.



\subsubsection{Accessing and deleting elements}

\paragraph{Accessing elements}
It works in a similar way as for vectors, except that the dimensions are separated with a comma.
Let's work with \mcode{M}:
\begin{lstlisting}
>> M = [ [1,2,3]; [4,5,6]; [7,8,9]]
M = 
1 2 3
4 5 6
7 8 9
\end{lstlisting}

To extract the third column of \mcode{M}:

\begin{lstlisting}
>> c = M(:,3)
c = 
3
6
9
\end{lstlisting}


To extract the second row of \mcode{M}:

\begin{lstlisting}
>> l = M(2,:)
l = 
4 5 6
\end{lstlisting}

To extract the first \emph{and} the second row of \mcode{M}:
\begin{lstlisting}
>> A = M([1,2],:)
A = 
1 2 3
4 5 6
\end{lstlisting}

Following this notation, we can exchange the first rows of \mcode{M}:
\begin{lstlisting}
>> A = M([2,1],:)
A = 
4 5 6
1 2 3
\end{lstlisting}



\tipbox{
	Using lists (for instance \mcode{indices = [1,3,4]}) as arguments of matrices is a very powerful methods for altering a matrix or for creating a new one.
\begin{itemize}
	\item \mcode{M(indices,:)} will select the rows of \mcode{M} in the order of the elements of \mcode{indices}. \\
		They can be copied, if there is repetition in \mcode{indices}, as \mcode{indices = [1,2,2]}
		They can be rearranged, if the elements in \mcode{indices} are not ranked, as \mcode{indices = [3,1,2]}
	\item \mcode{M(:,indices)} will select the rows of \mcode{M} in the order of the elements of indices
	\item \mcode{M(indices\_row,indices\_col)} will extract a sub-matrix of \mcode{M}

\end{itemize}


}


\paragraph{Deleting elements}




In \matlab, using "[]" empty a variable. It is named the \emph{empty vector operator}.
	
When used on a part of a vector or a matrix, it simply \emph{deletes} this part.
It is \emph{gone}.
As a consequence, it reduces the dimensions of the matrix.



It hence reduces the dimension of the vector. It works similarly for a matrix:
\begin{lstlisting}
>> A = [ [1 3 4] ; [-2.5 8 9]] ;
>> A(:,1) = []
A = 
3 4
8 9
\end{lstlisting}
The first column has been deleted.


It is possible to delete one element from a vector 

\begin{lstlisting}
>> v = [1 3 4 -2.5 8] ;
>> v(1) = []
v = 
3 4 -2.5 8
\end{lstlisting}

But trying to do it for a matrix will lead to an error message.
\begin{lstlisting}
>> A = [ [1 3 4] ; [-2.5 8 9]] ;
>> A(1,1) = []
<@{\color{red} A null assignment can have only one non-colon index.}@>
\end{lstlisting}

You can remove a block, a column or a row from a matrix. 
But you can not remove a single element, if not, there would be a "hole".


\section{Useful built-in functions for vectors and matrices}
\subsection{Dimensions of a matrix}
The command \mcode{size} send back the dimensions of a matrix.
\begin{lstlisting}
>> A = [ [1 3 4] ; [-2.5 8 9]] ; v = [1 2 3 4];
>> size(A)
ans = 
2 3
>> size(A(:))
ans =
6 1
>> size(A(1,:))
ans =
1 3
>> size(v)
ans = 
1 4
>> size(v')
ans = 
4 1
\end{lstlisting}
To reuse the size, you can store it in variables:
\begin{lstlisting}
>> A = [ [1 3 4] ; [-2.5 8 9]] ; 
>> size_a = size(A);
>> size_a(1)
ans =
3
>> [n_x,n_y] = size(A);
>> n_x
ans = 
3
>> n_y
ans = 
2
\end{lstlisting}


\subsection{Generating a vector}

\subsubsection{The colon operator}
\label{sssec-colon}
One of the most powerful operator in \matlab is the colon operator ":".
It allows in particular to generate lists.

We have seen already that \mcode{v(2:5)} gives the elements of \mcode{v} between the 2nd and 5th position.
What it does is actually ask \matlab to send back elements of \mcode{v} in position $2,3,4,5$.
These positions are \emph{generated} by the command \mcode{2:5}.
\begin{lstlisting}
>> 2:5
ans = 
2 3 4 5
\end{lstlisting}

The command \mcode{a:b} hence generates a vector, starting in a, each element being incremented by 1, until it would be greater than b.
\begin{lstlisting}
>> 4:8
ans = 
4 5 6 7 8
>> 4.5:8
ans = 
4.5 5.5 6.5 7.5
\end{lstlisting}
In the second example, the last item is $7.5$. $8.5$ would be larger than $8$ and is hence omitted.

It is possible to force the increment. 
The command \mcode{a:da:b} generates a vector, starting in a, each element being incremented by da, until it would be greater than b.
\begin{lstlisting}
>> 0:.1:1
ans = 
0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.
\end{lstlisting}

\subsubsection{Other functions}

\begin{table}[h!]
	\caption{A few functions that generate vectors.}
	\label{tab-func}
\center
\begin{tabular}{|l|c|l|}
	\hline
	name & description & illustration\\
	\hline
	colon operator : & see Sec~\ref{sssec-colon} & 0:10:.5 \\
	\mcode{linspace(a,b,n)} & linearly spaced n-dimensional vector & \mcode{linspace(0,1,11)} \\
							& between a and b & \\
	\mcode{diag(A)} & diagonal of matrix (A)  & \mcode{diag([[1,2];[3,4]])} \\
							& between a and b & \\	
	\hline
\end{tabular}
\end{table}



\subsection{Generating a matrix}
\begin{table}[h!]
	\caption{A few functions that generate matrices.}
	\label{tab-func}
\center
\begin{tabular}{|l|c|l|}
	\hline
	name & description & illustration\\
	\hline
	\mcode{zeros(m,n)} & $m,n$-dimensional matrix filled with $0$ & \mcode{zeros(2,4)} \\
	\mcode{ones(m,n)} & $m,n$-dimensional matrix filled with $1$ & \mcode{ones(2,4)} \\
	\mcode{rand(m,n)} & $m,n$-dimensional matrix filled with  & \mcode{rand(2,4)} \\
					 & random numbers taken between $0$ and $1$ &  \\
	\mcode{eye(n)} & n-dimensional identify matrix & \mcode{eye(10)} \\
	\mcode{diag(v)} & matrix filled with 0 with \mcode{v} as diagonal & \mcode{diag([1,2,3])} \\
	\hline
\end{tabular}
\end{table}

\begin{table}[h!]
	\caption{A few functions that are useful.}
	\label{tab-useful_func_algebra}
\center
\begin{tabular}{|l|c|l|}
	\hline
	name & description & illustration\\
	\hline
	\mcode{size(M)} & number of elements in M & \mcode{size([1,2,3])} \\
	\mcode{shape(M)} & number of elements in each direction of M & \mcode{shape([2,3,5];[1,2,3]])} \\
	\hline
\end{tabular}
\end{table}



\section{Linear Algebra}

\section{What to remember}
\subsection{Creating a matrix}
Follow the procedure:
\begin{itemize}
	\item start with a bracket [
	\item write each element of a column, separated with space or commas
	\item separate rows with a semi-colon
	\item end with the bracket ]
\end{itemize}

\subsection{Manipulating matrices}
You can
\begin{itemize}
	\item add (with "+"), subtract (with "-"), multiply (with "*") matrices if their sizes are compatible
	\item access to the ith element of matrix \mcode{M} using \mcode{M(i)}
	\item access to the (ith,jth) element of matrix \mcode{M} using \mcode{M(i,j)}
\end{itemize}	

\subsection{Key example}
Let's summarize in a few examples everything we have seen.

\begin{lstlisting}
>> M = [[1,2];[3,4]]
M = 
1 2 
3 4
\end{lstlisting}






\chapter{Plotting data}



One of the usefulness of \matlab is being able to easily plot, manipulate and modify data.

With only a few commands, you can have publication-ready figures.

\section{Creating the first plot}

First one needs data.

\begin{lstlisting}
>> x = [1 2 3 4 5 6 7 8 9 10];
>> y = [1 4 9 16 25 36 64 81 100];
\end{lstlisting}

To plot the data, the main command in \matlab is \mcode{plot}:

\begin{lstlisting}
>> plot(x,y)
\end{lstlisting}

\todoimage{plot 1}






\tipbox{
When only one data is provided, \matlab assumes that the abscisse are the indexes of the elements of the data. 

What will be plotted is hence the coordinates $(1,y(1)), (2,y(2), \hdots , (n, y(n))$.

Compare \mcode{plot(x,y)} and \mcode{plot(y)}!

When trying to understand some results, never hesitate to plot some data \mcode{y} by typing \mcode{plot(y)} in the command prompt. Quick and dirty, but useful.
}






\section{A beautiful plot}

\paragraph{axis}
It is \emph{really important} to always have labels for the axis.

\begin{lstlisting}
>> x = [1 2 3 4 5 6 7 8 9 10];
>> y = [1 4 9 16 25 36 64 81 100];
>> plot(x,y)
>> xlabel('data along x')
>> ylabel('data along y')
\end{lstlisting}

\mcode{xlabel} and \mcode{ylabel} are the \matlab functions that handle the labels.

You can see that the argument for these functions are between quotes "'".
A label is some text: it means that \matlab will need a string.


\begin{lstlisting}
>> x = 0:pi/10:2.*pi;
>> y = cos(x);
>> plot(x,y)
>> str_xlabel = 'x';
>> xlabel(str_xlabel)
>> str_ylabel = 'cos(x)';
>> ylabel(str_ylabel)
\end{lstlisting}

\paragraph{Colours and line styles}
The default plot color in \matlab is blue, and the line default style is plain.



To change the style, an extra argument has to be sent to \matlab.

For instance, 
\begin{itemize}
	\item \mcode{plot(x,y,'r')} will change the color of the plot to red.
	\item \mcode{plot(x,y,'--')} will change the line style of the plot to dashed.
\end{itemize}
Note that the argument is between quotes.
Arguments are generally passed as a string


\begin{table}[h!]
	\caption{A few colours in \matlab.}
	\label{tab-col}
\center
\begin{tabular}{|l|c|l|}
	\hline
	colours & code & illustration \\
	\hline
	black & k & \mcode{plot(x,y,'k')} \\
	green & g & \mcode{plot(x,y,'g')} \\
	red & r & \mcode{plot(x,y,'r')} \\
	blue & b & \mcode{plot(x,y,'b')} \\
	yellow & y & \mcode{plot(x,y,'y')} \\
	\hline
	\hline
\end{tabular}
\end{table}

\begin{table}[h!]
	\caption{A few line styles in \matlab.}
	\label{tab-lines}
\center
\begin{tabular}{|l|c|l|}
	\hline
	style & code & illustration \\
	\hline
	solid & - & \mcode{plot(x,y,'-')} \\
	dashed & -- & \mcode{plot(x,y,'--')} \\
	dotted & : & \mcode{plot(x,y,':')} \\
	dash-dot & -. & \mcode{plot(x,y,'-.')} \\
	\hline
	\hline
\end{tabular}
\end{table}


\begin{table}[h!]
	\caption{A few marker styles in \matlab.}
	\label{tab-marker}
\center
\begin{tabular}{|l|c|l|}
	\hline
	marker & code & illustration \\
	\hline
	plus & + & \mcode{plot(x,y,'+')} \\
	cross & x & \mcode{plot(x,y,'x')} \\
	circle & o & \mcode{plot(x,y,'o')} \\
	triangle up & \^{} & \mcode{plot(x,y,'\^{}')} \\
	triangle down & v & \mcode{plot(x,y,'v')} \\
	triangle left & \textless & \mcode{plot(x,y,'<')} \\
	triangle right & \textgreater & \mcode{plot(x,y,'>')} \\
	\hline
	\hline
\end{tabular}
\end{table}


\tipbox{
	A good way of not messing with the style is to follow this order:
	\begin{enumerate}
		\item open the quotes: \mcode{'}
		\item add the color, e.g. k: \mcode{'k}
		\item add the style of the line, e.g. --: \mcode{'k--}
		\item add the style of the markers, e.g. x: \mcode{'k--x}
		\item end the quotes: \mcode{'k--x'}
	\end{enumerate}
}


\tipbox{A good plot has {\color{red} \large always}:
	\begin{itemize}
		\item labels on the x-axis and y-axis
		\item different colors or patterns for different curves\\ If possible, these differences should persist when printing the figure in black and white.
	\end{itemize}
	If the figure is in a report :
	\begin{itemize}
		\item instead of a title, the figure can be explained in the text under the figure.
		\item instead of a legend, the difference between curves can be explained in the text under the figure.
	\end{itemize}

}

\subsection{Title}




The command \mcode{figure} is used here for opening a new figure.
If not, \matlab will draw any new plot in the previous figure, erasing the old figure.



\section{Edit a plot in the window}

A way to edit the plot properties is to click on the arrow - Edit Plot - on the plot window.
\todoimage{fig plot with arrow}

Then, double clicking on the curve will open an extra window where you can play with the properties.

In particular there is two interesting properties:
\begin{enumerate}
	\item \mcode{Line}, where you can edit the style of line (plain, dashed, etc.), the width of the line, and its color
	\item \mcode{Marker}, where you can edit the type of markers (indication where each data is plotted, for instance with circles), the size of the markers, the color of the inside of the marker as well as the color of their edges
\end{enumerate}



\bibliographystyle{ieeetr}
\bibliography{biblio}

\end{document}

%%
%% End of file `elsarticle-template-3a-num.tex'.
